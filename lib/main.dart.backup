import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';
import 'dart:async';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:provider/provider.dart';

// Simple singleton to manage team data across screens
class TeamDataManager {
  static final TeamDataManager _instance = TeamDataManager._internal();
  factory TeamDataManager() => _instance;
  TeamDataManager._internal();

  List<Map<String, dynamic>> _players = [
    {'id': '1', 'name': 'John Doe', 'shirtNumber': 10, 'assignment': 'NA', 'createdAt': DateTime.now().millisecondsSinceEpoch - 5000},
    {'id': '2', 'name': 'Mike Smith', 'shirtNumber': 7, 'assignment': 'NA', 'createdAt': DateTime.now().millisecondsSinceEpoch - 4000},
    {'id': '3', 'name': 'Alex Johnson', 'shirtNumber': 9, 'assignment': 'NA', 'createdAt': DateTime.now().millisecondsSinceEpoch - 3000},
    {'id': '4', 'name': 'Tom Wilson', 'shirtNumber': 5, 'assignment': 'NA', 'createdAt': DateTime.now().millisecondsSinceEpoch - 2000},
    {'id': '5', 'name': 'Sam Brown', 'shirtNumber': 3, 'assignment': 'NA', 'createdAt': DateTime.now().millisecondsSinceEpoch - 1000},
  ];

  // Load data from SharedPreferences
  Future<void> loadData() async {
    final prefs = await SharedPreferences.getInstance();
    final playersJson = prefs.getString('team_players');
    if (playersJson != null) {
      final List<dynamic> playersList = json.decode(playersJson);
      _players = playersList.map((player) => Map<String, dynamic>.from(player)).toList();
    }
  }

  // Save data to SharedPreferences
  Future<void> saveData() async {
    final prefs = await SharedPreferences.getInstance();
    final playersJson = json.encode(_players);
    await prefs.setString('team_players', playersJson);
  }

  List<Map<String, dynamic>> get players {
    // Sort by shirt number, then by creation date
    final sortedPlayers = List<Map<String, dynamic>>.from(_players);
    sortedPlayers.sort((a, b) {
      final shirtCompare = (a['shirtNumber'] as int).compareTo(b['shirtNumber'] as int);
      if (shirtCompare != 0) return shirtCompare;
      return (a['createdAt'] ?? 0).compareTo(b['createdAt'] ?? 0);
    });
    return sortedPlayers;
  }

  void addPlayer(Map<String, dynamic> player) {
    _players.add(player);
    saveData();
  }

  void removePlayer(String playerId) {
    _players.removeWhere((p) => p['id'] == playerId);
    saveData();
  }

  void updatePlayerAssignment(String playerId, String assignment) {
    final playerIndex = _players.indexWhere((p) => p['id'] == playerId);
    if (playerIndex != -1) {
      _players[playerIndex]['assignment'] = assignment;
      saveData();
    }
  }

  List<Map<String, dynamic>> getTeam1Players() {
    return _players.where((p) => p['assignment'] == 'TEAM1').toList();
  }

  List<Map<String, dynamic>> getTeam2Players() {
    return _players.where((p) => p['assignment'] == 'TEAM2').toList();
  }
}

// Calendar Provider for Training
class TrainingCalendarProvider extends ChangeNotifier {
  Map<String, Map<String, dynamic>> _notes = {};
  bool _isLoading = true;

  Map<String, Map<String, dynamic>> get notes => _notes;
  bool get isLoading => _isLoading;

  Future<void> loadNotes() async {
    _isLoading = true;
    notifyListeners();
    
    final prefs = await SharedPreferences.getInstance();
    final notesJson = prefs.getString('training_notes');
    if (notesJson != null) {
      final Map<String, dynamic> decoded = json.decode(notesJson);
      _notes = decoded.map((key, value) => MapEntry(key, Map<String, dynamic>.from(value)));
    }
    
    _isLoading = false;
    notifyListeners();
  }

  Future<void> saveNote(String date, String content) async {
    _notes[date] = {
      'date': date,
      'content': content,
      'updatedAt': DateTime.now().millisecondsSinceEpoch,
    };
    notifyListeners();
    
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('training_notes', json.encode(_notes));
  }

  Future<void> deleteNote(String date) async {
    _notes.remove(date);
    notifyListeners();
    
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('training_notes', json.encode(_notes));
  }

  String? getNote(String date) {
    return _notes[date]?['content'];
  }

  bool hasNote(String date) {
    return _notes.containsKey(date) && _notes[date]!['content'].toString().isNotEmpty;
  }
}

// Calendar Provider for Program
class ProgramCalendarProvider extends ChangeNotifier {
  Map<String, Map<String, dynamic>> _notes = {};
  bool _isLoading = true;

  Map<String, Map<String, dynamic>> get notes => _notes;
  bool get isLoading => _isLoading;

  Future<void> loadNotes() async {
    _isLoading = true;
    notifyListeners();
    
    final prefs = await SharedPreferences.getInstance();
    final notesJson = prefs.getString('program_notes');
    if (notesJson != null) {
      final Map<String, dynamic> decoded = json.decode(notesJson);
      _notes = decoded.map((key, value) => MapEntry(key, Map<String, dynamic>.from(value)));
    }
    
    _isLoading = false;
    notifyListeners();
  }

  Future<void> saveNote(String date, String content) async {
    _notes[date] = {
      'date': date,
      'content': content,
      'updatedAt': DateTime.now().millisecondsSinceEpoch,
    };
    notifyListeners();
    
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('program_notes', json.encode(_notes));
  }

  Future<void> deleteNote(String date) async {
    _notes.remove(date);
    notifyListeners();
    
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('program_notes', json.encode(_notes));
  }

  String? getNote(String date) {
    return _notes[date]?['content'];
  }

  bool hasNote(String date) {
    return _notes.containsKey(date) && _notes[date]!['content'].toString().isNotEmpty;
  }
}

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => TrainingCalendarProvider()),
        ChangeNotifierProvider(create: (_) => ProgramCalendarProvider()),
      ],
      child: MaterialApp(
        title: 'CoachGuru',
        theme: ThemeData(
          useMaterial3: true,
          colorScheme: ColorScheme.fromSeed(
            seedColor: Colors.blue,
            brightness: Brightness.light,
          ),
        ),
        home: MainScreen(),
      ),
    );
  }
}

class MainScreen extends StatefulWidget {
  @override
  _MainScreenState createState() => _MainScreenState();
}

class _MainScreenState extends State<MainScreen> {
  int _selectedIndex = 0;

  final List<Widget> _screens = [
    HomeScreen(),
    TeamScreen(),
    ProgramScreen(),
    TacticScreen(),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _screens[_selectedIndex],
      bottomNavigationBar: BottomNavigationBar(
        type: BottomNavigationBarType.fixed,
        currentIndex: _selectedIndex,
        onTap: (index) {
          setState(() {
            _selectedIndex = index;
          });
        },
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'Home',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.group),
            label: 'Team',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.calendar_today),
            label: 'Program',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.sports_soccer),
            label: 'Tactic',
          ),
        ],
      ),
    );
  }
}

class HomeScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF5F5F5),
      appBar: AppBar(
        title: const Text(
          'CoachGuru',
          style: TextStyle(
            color: Colors.black87,
            fontWeight: FontWeight.w500,
          ),
        ),
        centerTitle: true,
        backgroundColor: const Color(0xFF90EE90),
        elevation: 0,
        systemOverlayStyle: const SystemUiOverlayStyle(
          statusBarColor: Color(0xFF90EE90),
          statusBarIconBrightness: Brightness.dark,
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
        children: [
              // Blue Profile/Brand Card
          Container(
                width: double.infinity,
                padding: const EdgeInsets.all(24.0),
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    begin: Alignment.topLeft,
                    end: Alignment.bottomRight,
                    colors: [
                      Color(0xFF4A90E2),
                      Color(0xFF2E5BBA),
                    ],
                  ),
                  borderRadius: BorderRadius.circular(24.0),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      blurRadius: 10,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
        child: Column(
              children: [
                    // Circular Avatar
                    Container(
                      width: 80,
                      height: 80,
                      decoration: const BoxDecoration(
                        color: Color(0xFF87CEEB),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(
                        Icons.person,
                        size: 40,
                        color: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 16),
                    
                    // Two Orange Icons
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Container(
                          width: 32,
                          height: 32,
                          decoration: BoxDecoration(
                            color: Colors.orange,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: const Icon(
                            Icons.trending_up,
                            color: Colors.white,
                            size: 20,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Container(
                          width: 32,
                          height: 32,
                          decoration: BoxDecoration(
                            color: Colors.orange,
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: const Icon(
                            Icons.bar_chart,
                            color: Colors.white,
                            size: 20,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),
                    
                    // Title
                    const Text(
                      'CoachGuru',
                  style: TextStyle(
                        color: Colors.white,
                        fontSize: 24,
                    fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    
                    // Subtitle
                    const Text(
                      'Professional Coaching',
                  style: TextStyle(
                        color: Colors.white,
                    fontSize: 16,
                        fontWeight: FontWeight.w400,
                  ),
                ),
              ],
            ),
          ),
              
              const SizedBox(height: 32),
              
              // Quick Actions Section Label
              const Text(
                'Quick Actions',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.black87,
                ),
              ),
              
              const SizedBox(height: 16),
              
              // Quick Actions List
              _buildActionCard(
                  context,
                 icon: Icons.sports_soccer,
                 iconColor: Colors.blue,
                 title: 'New Match',
                 subtitle: 'Start a new match',
                 onTap: () => _navigateToStartMatch(context),
               ),
               const SizedBox(height: 12),
               _buildActionCard(
                  context,
                 icon: Icons.assignment,
                 iconColor: Colors.green,
                 title: 'New Report',
                 subtitle: 'Create scouting report',
                 onTap: () => _navigateToScouting(context),
               ),
               const SizedBox(height: 12),
               _buildActionCard(
                  context,
                 icon: Icons.sports,
                 iconColor: Colors.orange,
                 title: 'Tactic',
                 subtitle: 'Tactics board',
                 onTap: () => _navigateToScreen(context, 3),
               ),
               const SizedBox(height: 12),
               _buildActionCard(
                  context,
                 icon: Icons.fitness_center,
                 iconColor: Colors.purple,
                 title: 'Trainings',
                 subtitle: 'Training sessions',
                 onTap: () => _navigateToScreen(context, 1),
                ),
              ],
            ),
          ),
      ),
    );
  }

  Widget _buildActionCard(
    BuildContext context, {
    required IconData icon,
    required Color iconColor,
    required String title,
    required String subtitle,
    required VoidCallback onTap,
  }) {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.symmetric(horizontal: 0),
      child: Material(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        elevation: 2,
      child: InkWell(
          borderRadius: BorderRadius.circular(12),
        onTap: onTap,
        child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Row(
              children: [
                Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    color: iconColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Icon(
                    icon,
                    color: iconColor,
                    size: 24,
                  ),
                ),
                const SizedBox(width: 16),
                Expanded(
          child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                          color: Colors.black87,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        subtitle,
                        style: const TextStyle(
                          fontSize: 14,
                          color: Colors.grey,
                        ),
                      ),
                    ],
                  ),
                ),
                const Icon(
                  Icons.chevron_right,
                  color: Colors.grey,
                  size: 24,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _navigateToScreen(BuildContext context, int index) {
    final mainScreen = context.findAncestorStateOfType<_MainScreenState>();
    if (mainScreen != null) {
      mainScreen.setState(() {
        mainScreen._selectedIndex = index;
      });
    }
  }

  void _navigateToStartMatch(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => StartMatchScreen()),
    );
  }

  void _navigateToScouting(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => ScoutingScreen()),
    );
  }
}

class TeamScreen extends StatefulWidget {
  @override
  _TeamScreenState createState() => _TeamScreenState();
}

class _TeamScreenState extends State<TeamScreen> {
  final TeamDataManager _teamDataManager = TeamDataManager();
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    await _teamDataManager.loadData();
    setState(() {
      _isLoading = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('CoachGuru'),
          centerTitle: true,
          backgroundColor: const Color(0xFF90EE90),
          foregroundColor: Colors.black87,
          elevation: 0,
          systemOverlayStyle: const SystemUiOverlayStyle(
            statusBarColor: Color(0xFF90EE90),
            statusBarIconBrightness: Brightness.dark,
          ),
        ),
        body: const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }
    final players = _teamDataManager.players;

    return Scaffold(
      appBar: AppBar(
        title: const Text('CoachGuru'),
        centerTitle: true,
        backgroundColor: const Color(0xFF90EE90),
        foregroundColor: Colors.black87,
        elevation: 0,
        systemOverlayStyle: const SystemUiOverlayStyle(
          statusBarColor: Color(0xFF90EE90),
          statusBarIconBrightness: Brightness.dark,
        ),
      ),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Team Management',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Colors.black87,
                  ),
                ),
                FloatingActionButton(
                  onPressed: players.length >= 22 ? null : _showAddPlayerDialog,
                  backgroundColor: const Color(0xFF4CAF50),
                  child: const Icon(Icons.add, color: Colors.white),
                ),
              ],
            ),
          ),
          if (players.length >= 22)
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 16.0),
              child: Text(
                'Maximum 22 players reached',
                style: TextStyle(color: Colors.red, fontSize: 12),
              ),
            ),
          Expanded(
            child: ListView.builder(
              itemCount: players.length,
              itemBuilder: (context, index) {
                final player = players[index];
                
                return Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                  elevation: 2,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
      child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
        children: [
                        Row(
                          children: [
                            // Blue circular badge with player number
                            Container(
                              width: 40,
                              height: 40,
                              decoration: const BoxDecoration(
                                color: Color(0xFF2196F3),
                                shape: BoxShape.circle,
                              ),
                              child: Center(
                                child: Text(
                                  '${player['shirtNumber']}',
                                  style: const TextStyle(
                                    color: Colors.white,
                                    fontWeight: FontWeight.bold,
                                    fontSize: 16,
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(width: 12),
                            // Player name
                            Expanded(
                              child: Text(
                                player['name'],
                                style: const TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.w500,
                                  color: Colors.black87,
                                ),
                              ),
                            ),
                            // Delete button
                            IconButton(
                              icon: const Icon(Icons.delete, color: Colors.red, size: 20),
                              onPressed: () => _showDeleteConfirmation(player),
                              padding: EdgeInsets.zero,
                              constraints: const BoxConstraints(),
                            ),
                          ],
                        ),
                        const SizedBox(height: 12),
                        // Assignment Control
                        SegmentedButton<String>(
                          segments: const [
                            ButtonSegment(
                              value: 'TEAM1',
                              label: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(Icons.check, size: 16, color: Colors.white),
                                  SizedBox(width: 4),
                                  Text('Team 1'),
                                ],
                              ),
                            ),
                            ButtonSegment(
                              value: 'TEAM2',
                              label: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(Icons.group, size: 16),
                                  SizedBox(width: 4),
                                  Text('Team 2'),
                                ],
                              ),
                            ),
                            ButtonSegment(
                              value: 'BENCH',
                              label: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(Icons.chair, size: 16),
                                  SizedBox(width: 4),
                                  Text('Bench'),
                                ],
                              ),
                            ),
                            ButtonSegment(
                              value: 'NA',
                              label: Text('N/A'),
                            ),
                          ],
                          selected: {player['assignment']},
                          onSelectionChanged: (Set<String> selection) {
                            setState(() {
                              _teamDataManager.updatePlayerAssignment(player['id'], selection.first);
                            });
                          },
                          style: SegmentedButton.styleFrom(
                            selectedBackgroundColor: const Color(0xFF4CAF50),
                            selectedForegroundColor: Colors.white,
                            backgroundColor: Colors.white,
                            foregroundColor: Colors.black87,
                            side: const BorderSide(color: Colors.grey, width: 1),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  void _showDeleteConfirmation(Map<String, dynamic> player) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Player'),
        content: Text('Are you sure you want to delete ${player['name']}?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              setState(() {
                _teamDataManager.removePlayer(player['id']);
              });
              Navigator.pop(context);
            },
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _showAddPlayerDialog() {
    final nameController = TextEditingController();
    final numberController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add Player'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
        children: [
            TextField(
              controller: nameController,
              decoration: const InputDecoration(labelText: 'Name'),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: numberController,
              decoration: const InputDecoration(labelText: 'T-Shirt Number'),
              keyboardType: TextInputType.number,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              if (nameController.text.isNotEmpty && numberController.text.isNotEmpty) {
                final shirtNumber = int.tryParse(numberController.text);
                if (shirtNumber != null) {
                  setState(() {
                    _teamDataManager.addPlayer({
                      'id': DateTime.now().millisecondsSinceEpoch.toString(),
                      'name': nameController.text,
                      'shirtNumber': shirtNumber,
                      'assignment': 'NA',
                      'createdAt': DateTime.now().millisecondsSinceEpoch,
                    });
                  });
                  Navigator.pop(context);
                }
              }
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }
}

class ProgramScreen extends StatefulWidget {
  @override
  _ProgramScreenState createState() => _ProgramScreenState();
}

class _ProgramScreenState extends State<ProgramScreen> {
  DateTime _currentDate = DateTime.now();
  DateTime _selectedDate = DateTime.now();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<ProgramCalendarProvider>().loadNotes();
    });
  }

  String _formatDate(DateTime date) {
    return DateFormat('yyyy-MM-dd').format(date);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Program'),
        backgroundColor: Colors.green,
        foregroundColor: Colors.white,
        elevation: 0,
        systemOverlayStyle: const SystemUiOverlayStyle(
          statusBarColor: Colors.green,
          statusBarIconBrightness: Brightness.light,
        ),
      ),
      body: Consumer<ProgramCalendarProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }
          
          return Column(
            children: [
              // Month Navigation
              Container(
                padding: const EdgeInsets.all(16),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    IconButton(
                      onPressed: () {
                        setState(() {
                          _currentDate = DateTime(_currentDate.year, _currentDate.month - 1);
                        });
                      },
                      icon: const Icon(Icons.chevron_left),
                    ),
                    Text(
                      DateFormat('MMMM yyyy').format(_currentDate),
                      style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                    IconButton(
                      onPressed: () {
                        setState(() {
                          _currentDate = DateTime(_currentDate.year, _currentDate.month + 1);
                        });
                      },
                      icon: const Icon(Icons.chevron_right),
                    ),
                  ],
                ),
              ),
              
              // Calendar Grid
              Expanded(
                child: _buildCalendar(provider),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildCalendar(ProgramCalendarProvider provider) {
    final firstDayOfMonth = DateTime(_currentDate.year, _currentDate.month, 1);
    final lastDayOfMonth = DateTime(_currentDate.year, _currentDate.month + 1, 0);
    final firstDayWeekday = firstDayOfMonth.weekday;
    final daysInMonth = lastDayOfMonth.day;
    
    // Calculate total cells needed (including empty cells for days before month starts)
    final totalCells = firstDayWeekday - 1 + daysInMonth;
    final rows = (totalCells / 7).ceil();
    
    return Column(
      children: [
        // Weekday headers
        Container(
          padding: const EdgeInsets.symmetric(vertical: 8),
          child: Row(
            children: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
                .map((day) => Expanded(
                      child: Center(
                        child: Text(
                          day,
                          style: const TextStyle(fontWeight: FontWeight.bold),
                        ),
                      ),
                    ))
                .toList(),
          ),
        ),
        
        // Calendar grid
        Expanded(
          child: GridView.builder(
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 7,
              childAspectRatio: 1,
            ),
            itemCount: rows * 7,
            itemBuilder: (context, index) {
              final dayNumber = index - firstDayWeekday + 2;
              
              if (dayNumber < 1 || dayNumber > daysInMonth) {
                return Container(); // Empty cell
              }
              
              final date = DateTime(_currentDate.year, _currentDate.month, dayNumber);
              final dateString = _formatDate(date);
              final isToday = _formatDate(DateTime.now()) == dateString;
              final isSelected = _formatDate(_selectedDate) == dateString;
              final hasNote = provider.hasNote(dateString);
              
              return GestureDetector(
                onTap: () {
                  setState(() {
                    _selectedDate = date;
                  });
                  _showNoteDialog(provider, dateString);
                },
                child: Container(
                  margin: const EdgeInsets.all(2),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? Colors.blue
                        : isToday
                            ? Colors.green.withOpacity(0.3)
                            : Colors.transparent,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(
                      color: isToday ? Colors.green : Colors.grey.withOpacity(0.3),
                      width: isToday ? 2 : 1,
                    ),
                  ),
                  child: Stack(
                    children: [
                      Center(
                        child: Text(
                          dayNumber.toString(),
                          style: TextStyle(
                            color: isSelected ? Colors.white : Colors.black,
                            fontWeight: isToday ? FontWeight.bold : FontWeight.normal,
                          ),
                        ),
                      ),
                      if (hasNote)
                        Positioned(
                          top: 4,
                          right: 4,
                          child: Container(
                            width: 8,
                            height: 8,
                            decoration: const BoxDecoration(
                              color: Colors.red,
                              shape: BoxShape.circle,
                            ),
                          ),
                        ),
                    ],
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  void _showNoteDialog(ProgramCalendarProvider provider, String dateString) {
    final existingNote = provider.getNote(dateString) ?? '';
    final controller = TextEditingController(text: existingNote);
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => Padding(
        padding: EdgeInsets.only(
          bottom: MediaQuery.of(context).viewInsets.bottom,
        ),
        child: Container(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                DateFormat('EEEE, MMMM d, yyyy').format(DateTime.parse(dateString)),
                style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: controller,
                decoration: const InputDecoration(
                  labelText: 'Notes',
                  border: OutlineInputBorder(),
                ),
                maxLines: 5,
                autofocus: true,
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  if (existingNote.isNotEmpty)
                    TextButton(
                      onPressed: () {
                        provider.deleteNote(dateString);
                        Navigator.pop(context);
                      },
                      child: const Text('Delete', style: TextStyle(color: Colors.red)),
                    )
                  else
                    const SizedBox(),
                  ElevatedButton(
                    onPressed: () {
                      provider.saveNote(dateString, controller.text);
                      Navigator.pop(context);
                    },
                    child: const Text('Save'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class ProgramContent extends StatefulWidget {
  @override
  _ProgramContentState createState() => _ProgramContentState();
}

class _ProgramContentState extends State<ProgramContent> {
  List<Map<String, dynamic>> _fixtures = [];
  List<Map<String, dynamic>> _history = [];

  @override
  void initState() {
    super.initState();
    _checkAndMovePastFixtures();
    // Check every minute for past fixtures
    Timer.periodic(const Duration(minutes: 1), (timer) {
      _checkAndMovePastFixtures();
    });
  }

  void _checkAndMovePastFixtures() {
    final now = DateTime.now();
    final fixturesToMove = <Map<String, dynamic>>[];
    
    for (var fixture in _fixtures) {
      try {
        final dateTime = DateTime.parse('${fixture['date']} ${fixture['time']}');
        // Move to history if match time + 2 hours has passed
        if (now.isAfter(dateTime.add(const Duration(hours: 2)))) {
          fixturesToMove.add(fixture);
        }
      } catch (e) {
        // Skip invalid date formats
      }
    }
    
    if (fixturesToMove.isNotEmpty) {
      setState(() {
        _fixtures.removeWhere((fixture) => fixturesToMove.contains(fixture));
        _history.addAll(fixturesToMove);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Match Program',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
              ElevatedButton.icon(
                onPressed: _showAddFixtureDialog,
                icon: const Icon(Icons.add),
                label: const Text('Add Fixture'),
              ),
            ],
          ),
        ),
        Expanded(
          child: ListView.builder(
            itemCount: _fixtures.length,
            itemBuilder: (context, index) {
              final fixture = _fixtures[index];
              return Card(
                margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                child: ListTile(
                  title: Text(fixture['opponent']),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('Date: ${fixture['date']}'),
                      Text('Time: ${fixture['time']}'),
                      Text('Home/Away: ${fixture['home']}'),
                    ],
                  ),
                  trailing: IconButton(
                    icon: const Icon(Icons.delete, color: Colors.red),
                    onPressed: () => _showDeleteConfirmation(fixture),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  void _showDeleteConfirmation(Map<String, dynamic> fixture) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Fixture'),
        content: Text('Are you sure you want to delete ${fixture['opponent']}?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              setState(() {
                _fixtures.removeWhere((f) => f['id'] == fixture['id']);
              });
              Navigator.pop(context);
            },
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _showAddFixtureDialog() {
    final opponentController = TextEditingController();
    final dateController = TextEditingController();
    final timeController = TextEditingController();
    final homeController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add Fixture'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
        children: [
            TextField(
              controller: opponentController,
              decoration: const InputDecoration(labelText: 'Opponent'),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: dateController,
              decoration: const InputDecoration(labelText: 'Date (YYYY-MM-DD)'),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: timeController,
              decoration: const InputDecoration(labelText: 'Time (HH:MM)'),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: homeController,
              decoration: const InputDecoration(labelText: 'Home/Away'),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              if (opponentController.text.isNotEmpty && 
                  dateController.text.isNotEmpty && 
                  timeController.text.isNotEmpty && 
                  homeController.text.isNotEmpty) {
                setState(() {
                  _fixtures.add({
                    'id': DateTime.now().millisecondsSinceEpoch.toString(),
                    'opponent': opponentController.text,
                    'date': dateController.text,
                    'time': timeController.text,
                    'home': homeController.text,
                    'createdAt': DateTime.now(),
                  });
                });
                Navigator.pop(context);
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }
}

class HistoryContent extends StatefulWidget {
  @override
  _HistoryContentState createState() => _HistoryContentState();
}

class _HistoryContentState extends State<HistoryContent> {
  List<Map<String, dynamic>> _history = [];

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              const Text(
                'Match History',
                style: TextStyle(
                  fontSize: 20,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
        Expanded(
          child: _history.isEmpty
              ? const Center(
                  child: Text(
                    'No past matches yet.\n\nMatches will appear here automatically\n2 hours after their scheduled time.',
                    textAlign: TextAlign.center,
                    style: TextStyle(color: Colors.grey),
                  ),
                )
              : ListView.builder(
                  itemCount: _history.length,
                  itemBuilder: (context, index) {
                    final fixture = _history[index];
                    return Card(
                      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                      child: ListTile(
                        title: Text(fixture['opponent']),
                        subtitle: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text('Date: ${fixture['date']}'),
                            Text('Time: ${fixture['time']}'),
                            Text('Home/Away: ${fixture['home']}'),
                          ],
                        ),
                        trailing: IconButton(
                          icon: const Icon(Icons.delete, color: Colors.red),
                          onPressed: () => _showDeleteConfirmation(fixture),
                        ),
                      ),
                    );
                  },
                ),
        ),
      ],
    );
  }

  void _showDeleteConfirmation(Map<String, dynamic> fixture) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Match'),
        content: Text('Are you sure you want to delete ${fixture['opponent']}?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              setState(() {
                _history.removeWhere((f) => f['id'] == fixture['id']);
              });
              Navigator.pop(context);
            },
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
}

class StartMatchScreen extends StatefulWidget {
  @override
  _StartMatchScreenState createState() => _StartMatchScreenState();
}

class _StartMatchScreenState extends State<StartMatchScreen> with TickerProviderStateMixin {
  final _durationController = TextEditingController(text: '10');
  final _matchesController = TextEditingController(text: '1');
  final _fieldsController = TextEditingController(text: '1');
  
  String? _durationError;
  String? _matchesError;
  String? _fieldsError;

  final TeamDataManager _teamDataManager = TeamDataManager();
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    await _teamDataManager.loadData();
    final prefs = await SharedPreferences.getInstance();
    
    // Load saved match parameters
    final savedDuration = prefs.getString('match_duration') ?? '10';
    final savedMatches = prefs.getString('match_matches') ?? '1';
    final savedFields = prefs.getString('match_fields') ?? '1';
    
    setState(() {
      _durationController.text = savedDuration;
      _matchesController.text = savedMatches;
      _fieldsController.text = savedFields;
      _isLoading = false;
    });
  }

  Future<void> _saveMatchParameters() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('match_duration', _durationController.text);
    await prefs.setString('match_matches', _matchesController.text);
    await prefs.setString('match_fields', _fieldsController.text);
  }
  
  // Match state
  bool _isMatchRunning = false;
  int _currentMatch = 0;
  int _totalMatches = 0;
  int _totalFields = 0;
  int _matchDuration = 0;
  List<Timer> _timers = [];
  List<int> _remainingTimes = [];
  List<bool> _halfTimeReached = [];
  List<Map<String, dynamic>> _matchHistory = [];
  List<Map<String, dynamic>> _substitutions = [];

  @override
  void dispose() {
    // Cancel all timers when widget is disposed
    for (var timer in _timers) {
      timer.cancel();
    }
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('New Match'),
          backgroundColor: Colors.orange,
          foregroundColor: Colors.white,
        ),
        body: const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    // Get current team assignments from TeamDataManager
    final team1Players = _teamDataManager.getTeam1Players();
    final team2Players = _teamDataManager.getTeam2Players();
    final benchPlayers = _teamDataManager.players.where((p) => p['assignment'] == 'BENCH').toList();

    return Scaffold(
      appBar: AppBar(
        title: const Text('New Match'),
        backgroundColor: Colors.orange,
        foregroundColor: Colors.white,
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
      child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
        children: [
            // Match Inputs
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Match Settings',
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 16),
                    
                    // Match Duration
                    TextField(
                      controller: _durationController,
                      keyboardType: TextInputType.number,
                      decoration: InputDecoration(
                        labelText: 'Match Duration (minutes)',
                        errorText: _durationError,
                        border: const OutlineInputBorder(),
                      ),
                      onChanged: (value) => _validateDuration(value),
                    ),
                    const SizedBox(height: 16),
                    
                    // Number of Matches
                    TextField(
                      controller: _matchesController,
                      keyboardType: TextInputType.number,
                      decoration: InputDecoration(
                        labelText: 'Number of Matches',
                        errorText: _matchesError,
                        border: const OutlineInputBorder(),
                      ),
                      onChanged: (value) => _validateMatches(value),
                    ),
                    const SizedBox(height: 16),
                    
                    // Select Field
                    TextField(
                      controller: _fieldsController,
                      keyboardType: TextInputType.number,
                      decoration: InputDecoration(
                        labelText: 'Select Field (count)',
                        errorText: _fieldsError,
                        border: const OutlineInputBorder(),
                      ),
                      onChanged: (value) => _validateFields(value),
                    ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 16),
            
            // Current Lineup
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'Current Lineup:',
                      style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 16),
                    
                    if (team1Players.isEmpty && team2Players.isEmpty && benchPlayers.isEmpty)
                      const Text(
                        'Assign players in Team to populate the lineup.',
                        style: TextStyle(color: Colors.grey, fontStyle: FontStyle.italic),
                      )
                    else
                      Column(
                        children: [
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              // Team 1 Column
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Container(
                                      width: double.infinity,
                                      padding: const EdgeInsets.all(8),
                                      decoration: BoxDecoration(
                                        color: Colors.red.withOpacity(0.1),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: const Text(
                                        'Team 1',
                                        textAlign: TextAlign.center,
                                        style: TextStyle(fontWeight: FontWeight.bold),
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    ...team1Players.map((player) => Padding(
                                      padding: const EdgeInsets.symmetric(vertical: 2),
                                      child: Text('#${player['shirtNumber']} ${player['name']}'),
                                    )).toList(),
                                  ],
                                ),
                              ),
                              const SizedBox(width: 16),
                              // Team 2 Column
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Container(
                                      width: double.infinity,
                                      padding: const EdgeInsets.all(8),
                                      decoration: BoxDecoration(
                                        color: Colors.blue.withOpacity(0.1),
                                        borderRadius: BorderRadius.circular(8),
                                      ),
                                      child: const Text(
                                        'Team 2',
                                        textAlign: TextAlign.center,
                                        style: TextStyle(fontWeight: FontWeight.bold),
                                      ),
                                    ),
                                    const SizedBox(height: 8),
                                    ...team2Players.map((player) => Padding(
                                      padding: const EdgeInsets.symmetric(vertical: 2),
                                      child: Text('#${player['shirtNumber']} ${player['name']}'),
                                    )).toList(),
                                  ],
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 16),
                          // Bench Column
                          Container(
                            width: double.infinity,
                            padding: const EdgeInsets.all(8),
                            decoration: BoxDecoration(
                              color: Colors.orange.withOpacity(0.1),
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                const Text(
                                  'Bench',
                                  textAlign: TextAlign.center,
                                  style: TextStyle(fontWeight: FontWeight.bold),
                                ),
                                const SizedBox(height: 8),
                                if (benchPlayers.isEmpty)
                                  const Text(
                                    'No bench players',
                                    style: TextStyle(color: Colors.grey, fontStyle: FontStyle.italic),
                                  )
                                else
                                  Wrap(
                                    children: benchPlayers.map((player) => Padding(
                                      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
                                      child: Text('#${player['shirtNumber']} ${player['name']}'),
                                    )).toList(),
                                  ),
                              ],
                            ),
                          ),
                        ],
                      ),
                  ],
                ),
              ),
            ),
            
            const SizedBox(height: 16),
            
            // Substitutions Display
            if (_substitutions.isNotEmpty) ...[
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Substitutions:',
                        style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 8),
                      if (_totalFields == 1) ...[
                        // Single field - show all substitutions
                        ..._substitutions.map((sub) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 2),
                          child: Text(
                            '${sub['team']}: ${sub['playerOut']}  ${sub['playerIn']}',
                            style: const TextStyle(fontSize: 14),
                          ),
                        )).toList(),
                      ] else ...[
                        // Multiple fields - group by field
                        ...List.generate(_totalFields, (fieldIndex) {
                          final fieldSubs = _substitutions.where((sub) => sub['field'] == fieldIndex + 1).toList();
                          if (fieldSubs.isEmpty) return const SizedBox.shrink();
                          
                          return Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Field ${fieldIndex + 1}:',
                                style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold),
                              ),
                              ...fieldSubs.map((sub) => Padding(
                                padding: const EdgeInsets.only(left: 16, top: 2),
                                child: Text(
                                  '${sub['team']}: ${sub['playerOut']}  ${sub['playerIn']}',
                                  style: const TextStyle(fontSize: 14),
                                ),
                              )).toList(),
                              const SizedBox(height: 8),
                            ],
                          );
                        }),
                      ],
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
            ],
            
            // Match Controls
            if (!_isMatchRunning) ...[
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _canStartMatch() ? _startMatch : null,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.green,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                  ),
                  child: const Text(
                    'Start Match',
                    style: TextStyle(fontSize: 18, color: Colors.white),
                  ),
                ),
              ),
            ] else ...[
              // Match Timer Display
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      Text(
                        'Match $_currentMatch of $_totalMatches',
                        style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 16),
                      if (_totalFields == 1) ...[
                        // Single field timer
                        Text(
                          _formatTime(_remainingTimes[0]),
                          style: const TextStyle(fontSize: 48, fontWeight: FontWeight.bold, color: Colors.red),
                        ),
                      ] else ...[
                        // Multiple field timers
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                          children: List.generate(_totalFields, (index) {
                            return Column(
                              children: [
                                Text(
                                  'Field ${index + 1}',
                                  style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold),
                                ),
                                const SizedBox(height: 8),
                                Text(
                                  _formatTime(_remainingTimes[index]),
                                  style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.red),
                                ),
                              ],
                            );
                          }),
                        ),
                      ],
                      const SizedBox(height: 16),
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          onPressed: _stopMatch,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.red,
                            padding: const EdgeInsets.symmetric(vertical: 16),
                          ),
                          child: const Text(
                            'Stop Match',
                            style: TextStyle(fontSize: 18, color: Colors.white),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }

  void _validateDuration(String value) {
    final duration = int.tryParse(value);
    setState(() {
      if (duration == null || duration < 1 || duration > 45) {
        _durationError = 'Must be between 1-45 minutes';
      } else {
        _durationError = null;
      }
    });
    _saveMatchParameters();
  }

  void _validateMatches(String value) {
    final matches = int.tryParse(value);
    setState(() {
      if (matches == null || matches < 1 || matches > 6) {
        _matchesError = 'Must be between 1-6 matches';
      } else {
        _matchesError = null;
      }
    });
    _saveMatchParameters();
  }

  void _validateFields(String value) {
    final fields = int.tryParse(value);
    setState(() {
      if (fields == null || fields < 1 || fields > 4) {
        _fieldsError = 'Must be between 1-4 fields';
      } else {
        _fieldsError = null;
      }
    });
    _saveMatchParameters();
  }

  bool _canStartMatch() {
    return _durationError == null && 
           _matchesError == null && 
           _fieldsError == null &&
           _durationController.text.isNotEmpty &&
           _matchesController.text.isNotEmpty &&
           _fieldsController.text.isNotEmpty;
  }

  void _startMatch() {
    if (_canStartMatch()) {
      setState(() {
        _isMatchRunning = true;
        _currentMatch = 1;
        _totalMatches = int.parse(_matchesController.text);
        _totalFields = int.parse(_fieldsController.text);
        _matchDuration = int.parse(_durationController.text) * 60; // Convert to seconds
        
        // Initialize timers and states for each field
        _remainingTimes = List.filled(_totalFields, _matchDuration);
        _halfTimeReached = List.filled(_totalFields, false);
        _timers = [];
        _substitutions = [];
        
        // Start timers for each field
        for (int field = 0; field < _totalFields; field++) {
          _startFieldTimer(field);
        }
      });
    }
  }
  
  void _startFieldTimer(int fieldIndex) {
    _timers.add(Timer.periodic(const Duration(seconds: 1), (timer) {
      setState(() {
        _remainingTimes[fieldIndex]--;
        
        // Check for half-time substitution
        if (!_halfTimeReached[fieldIndex] && _remainingTimes[fieldIndex] <= _matchDuration ~/ 2) {
          _halfTimeReached[fieldIndex] = true;
          _performSubstitution(fieldIndex);
        }
        
        // Check if match is finished
        if (_remainingTimes[fieldIndex] <= 0) {
          timer.cancel();
          _onMatchFinished(fieldIndex);
        }
      });
    }));
  }
  
  void _performSubstitution(int fieldIndex) {
    // Get bench players
    final benchPlayers = _teamDataManager.players.where((p) => p['assignment'] == 'BENCH').toList();
    final team1Players = _teamDataManager.getTeam1Players();
    final team2Players = _teamDataManager.getTeam2Players();
    
    if (benchPlayers.isNotEmpty) {
      // Move one player from Team 1 to bench and one from bench to Team 1
      if (team1Players.isNotEmpty) {
        final playerToSubOut = team1Players.first;
        final playerToSubIn = benchPlayers.first;
        
        _teamDataManager.updatePlayerAssignment(playerToSubOut['id'], 'BENCH');
        _teamDataManager.updatePlayerAssignment(playerToSubIn['id'], 'TEAM1');
        
        // Record substitution
        _substitutions.add({
          'field': fieldIndex + 1,
          'team': 'Team 1',
          'playerOut': playerToSubOut['name'],
          'playerIn': playerToSubIn['name'],
          'time': _formatTime(_remainingTimes[fieldIndex]),
        });
      }
      
      // Move one player from Team 2 to bench and one from bench to Team 2
      if (team2Players.isNotEmpty && benchPlayers.length > 1) {
        final playerToSubOut = team2Players.first;
        final playerToSubIn = benchPlayers[1];
        
        _teamDataManager.updatePlayerAssignment(playerToSubOut['id'], 'BENCH');
        _teamDataManager.updatePlayerAssignment(playerToSubIn['id'], 'TEAM2');
        
        // Record substitution
        _substitutions.add({
          'field': fieldIndex + 1,
          'team': 'Team 2',
          'playerOut': playerToSubOut['name'],
          'playerIn': playerToSubIn['name'],
          'time': _formatTime(_remainingTimes[fieldIndex]),
        });
      }
    }
  }
  
  void _onMatchFinished(int fieldIndex) {
    // Add match to history
    _matchHistory.add({
      'matchNumber': _currentMatch,
      'field': fieldIndex + 1,
      'duration': _matchDuration,
      'timestamp': DateTime.now(),
      'team1Players': _teamDataManager.getTeam1Players().map((p) => p['name']).toList(),
      'team2Players': _teamDataManager.getTeam2Players().map((p) => p['name']).toList(),
    });
    
    // Check if all fields are finished
    bool allFieldsFinished = _remainingTimes.every((time) => time <= 0);
    
    if (allFieldsFinished) {
      _currentMatch++;
      
      if (_currentMatch > _totalMatches) {
        // All matches finished
        _finishAllMatches();
      } else {
        // Start next match
        _startNextMatch();
      }
    }
  }
  
  void _startNextMatch() {
    setState(() {
      _remainingTimes = List.filled(_totalFields, _matchDuration);
      _halfTimeReached = List.filled(_totalFields, false);
      _timers = [];
      _substitutions = [];
      
      // Start timers for each field
      for (int field = 0; field < _totalFields; field++) {
        _startFieldTimer(field);
      }
    });
  }
  
  void _finishAllMatches() {
    setState(() {
      _isMatchRunning = false;
      _currentMatch = 0;
    });
    
    // Cancel all timers
    for (var timer in _timers) {
      timer.cancel();
    }
    _timers.clear();
    
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('All Matches Finished!'),
        content: Text('Completed $_totalMatches matches. Match history has been saved.'),
        actions: [
          ElevatedButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }
  
  void _stopMatch() {
    setState(() {
      _isMatchRunning = false;
      _currentMatch = 0;
    });
    
    // Cancel all timers
    for (var timer in _timers) {
      timer.cancel();
    }
    _timers.clear();
  }
  
  String _formatTime(int seconds) {
    int minutes = seconds ~/ 60;
    int remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }
}



class DraggablePlayer {
  final String id;
  final int number;
  final Color color;
  bool isOnPitch;
  Offset position;

  DraggablePlayer({
    required this.id,
    required this.number,
    required this.color,
    required this.isOnPitch,
    required this.position,
  });
}

class FootballPitchPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.green
      ..style = PaintingStyle.fill;

    // Fill the entire canvas with green
    canvas.drawRect(Rect.fromLTWH(0, 0, size.width, size.height), paint);

    // Draw pitch lines
    final linePaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;

    // Calculate pitch dimensions (leaving some margin)
    final margin = 20.0;
    final pitchWidth = size.width - (margin * 2);
    final pitchHeight = size.height - (margin * 2);
    final pitchLeft = margin;
    final pitchTop = margin;

    // Outer boundary
    canvas.drawRect(
      Rect.fromLTWH(pitchLeft, pitchTop, pitchWidth, pitchHeight),
      linePaint,
    );

    // Center line
    canvas.drawLine(
      Offset(pitchLeft + pitchWidth / 2, pitchTop),
      Offset(pitchLeft + pitchWidth / 2, pitchTop + pitchHeight),
      linePaint,
    );

    // Center circle
    canvas.drawCircle(
      Offset(pitchLeft + pitchWidth / 2, pitchTop + pitchHeight / 2),
      pitchHeight * 0.15,
      linePaint,
    );

    // Center spot
    canvas.drawCircle(
      Offset(pitchLeft + pitchWidth / 2, pitchTop + pitchHeight / 2),
      3,
      Paint()..color = Colors.white,
    );

    // Left penalty area
    final penaltyAreaWidth = pitchWidth * 0.2;
    final penaltyAreaHeight = pitchHeight * 0.4;
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft,
        pitchTop + (pitchHeight - penaltyAreaHeight) / 2,
        penaltyAreaWidth,
        penaltyAreaHeight,
      ),
      linePaint,
    );

    // Left six-yard box
    final sixYardWidth = pitchWidth * 0.1;
    final sixYardHeight = pitchHeight * 0.25;
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft,
        pitchTop + (pitchHeight - sixYardHeight) / 2,
        sixYardWidth,
        sixYardHeight,
      ),
      linePaint,
    );

    // Left goal
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft - 5,
        pitchTop + (pitchHeight - pitchHeight * 0.2) / 2,
        5,
        pitchHeight * 0.2,
      ),
      linePaint,
    );

    // Right penalty area
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft + pitchWidth - penaltyAreaWidth,
        pitchTop + (pitchHeight - penaltyAreaHeight) / 2,
        penaltyAreaWidth,
        penaltyAreaHeight,
      ),
      linePaint,
    );

    // Right six-yard box
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft + pitchWidth - sixYardWidth,
        pitchTop + (pitchHeight - sixYardHeight) / 2,
        sixYardWidth,
        sixYardHeight,
      ),
      linePaint,
    );

    // Right goal
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft + pitchWidth,
        pitchTop + (pitchHeight - pitchHeight * 0.2) / 2,
        5,
        pitchHeight * 0.2,
      ),
      linePaint,
    );
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

class TacticScreen extends StatefulWidget {
  @override
  _TacticScreenState createState() => _TacticScreenState();
}

class _TacticScreenState extends State<TacticScreen> {
  List<DraggablePlayer> _playersOnPitch = [];
  List<DraggablePlayer> _bluePlayers = [];
  List<DraggablePlayer> _redPlayers = [];
  DraggablePlayer? _ball;

  @override
  void initState() {
    super.initState();
    _initializePlayers();
  }

  void _initializePlayers() {
    // Initialize blue players (1-11)
    _bluePlayers = List.generate(11, (index) {
      return DraggablePlayer(
        id: 'blue_${index + 1}',
        number: index + 1,
        color: Colors.blue,
        isOnPitch: false,
        position: Offset.zero,
      );
    });

    // Initialize red players (1-11)
    _redPlayers = List.generate(11, (index) {
      return DraggablePlayer(
        id: 'red_${index + 1}',
        number: index + 1,
        color: Colors.red,
        isOnPitch: false,
        position: Offset.zero,
      );
    });

    // Initialize ball
    _ball = DraggablePlayer(
      id: 'ball',
      number: 0,
      color: Colors.white,
      isOnPitch: false,
      position: Offset.zero,
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Tactic'),
        backgroundColor: Colors.green,
        foregroundColor: Colors.white,
        elevation: 0,
        systemOverlayStyle: const SystemUiOverlayStyle(
          statusBarColor: Colors.green,
          statusBarIconBrightness: Brightness.light,
        ),
      ),
      body: Stack(
        children: [
          // Football pitch
          Positioned.fill(
            child: CustomPaint(
              painter: FootballPitchPainter(),
            ),
          ),
          
          // Players on pitch
          ..._playersOnPitch.map((player) => _buildDraggablePlayer(player)),
          
          // Bottom dock with available players
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              height: 120,
              decoration: BoxDecoration(
                color: Colors.grey[100],
                border: Border(
                  top: BorderSide(color: Colors.grey[300]!, width: 1),
                ),
              ),
              child: Column(
                children: [
                  // Blue players
                  Expanded(
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      child: Row(
                        children: [
                          const Text('Blue:', style: TextStyle(fontWeight: FontWeight.bold)),
                          const SizedBox(width: 8),
                          Expanded(
                            child: SingleChildScrollView(
                              scrollDirection: Axis.horizontal,
                              child: Row(
                                children: _bluePlayers
                                    .where((p) => !p.isOnPitch)
                                    .map((player) => _buildDockPlayer(player))
                                    .toList(),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  
                  // Red players
                  Expanded(
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      child: Row(
                        children: [
                          const Text('Red:', style: TextStyle(fontWeight: FontWeight.bold)),
                          const SizedBox(width: 8),
                          Expanded(
                            child: SingleChildScrollView(
                              scrollDirection: Axis.horizontal,
                              child: Row(
                                children: _redPlayers
                                    .where((p) => !p.isOnPitch)
                                    .map((player) => _buildDockPlayer(player))
                                    .toList(),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  
                  // Ball
                  Expanded(
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                      child: Row(
                        children: [
                          const Text('Ball:', style: TextStyle(fontWeight: FontWeight.bold)),
                          const SizedBox(width: 8),
                          if (_ball != null && !_ball!.isOnPitch)
                            _buildDockPlayer(_ball!),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDockPlayer(DraggablePlayer player) {
    return Draggable<DraggablePlayer>(
      data: player,
      feedback: _buildPlayerChip(player, size: 40),
      childWhenDragging: Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: player.color.withOpacity(0.3),
          shape: BoxShape.circle,
        ),
      ),
      onDragEnd: (details) {
        setState(() {
          // Check if dropped on pitch area
          final screenSize = MediaQuery.of(context).size;
          final appBarHeight = kToolbarHeight + MediaQuery.of(context).padding.top;
          final pitchTop = appBarHeight;
          final pitchBottom = screenSize.height - 120; // Account for dock
          
          if (details.offset.dy >= pitchTop && details.offset.dy <= pitchBottom) {
            // Move player to pitch
            player.isOnPitch = true;
            player.position = details.offset;
            _playersOnPitch.add(player);
          }
        });
      },
      child: _buildPlayerChip(player, size: 40),
    );
  }

  Widget _buildDraggablePlayer(DraggablePlayer player) {
    return Positioned(
      left: player.position.dx - 20,
      top: player.position.dy - 20,
      child: Draggable<DraggablePlayer>(
        data: player,
        feedback: _buildPlayerChip(player, size: 44),
        onDragEnd: (details) {
          setState(() {
            // Clamp position to pitch bounds
            final screenSize = MediaQuery.of(context).size;
            final appBarHeight = kToolbarHeight + MediaQuery.of(context).padding.top;
            final pitchTop = appBarHeight;
            final pitchBottom = screenSize.height - 120; // Account for dock
            final pitchLeft = 0.0;
            final pitchRight = screenSize.width;
            
            final clampedX = details.offset.dx.clamp(pitchLeft + 20, pitchRight - 20);
            final clampedY = details.offset.dy.clamp(pitchTop + 20, pitchBottom - 20);
            
            player.position = Offset(clampedX, clampedY);
          });
        },
        child: _buildPlayerChip(player, size: 44),
      ),
    );
  }

  Widget _buildPlayerChip(DraggablePlayer player, {required double size}) {
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        color: player.color,
        shape: BoxShape.circle,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Center(
        child: player.id == 'ball'
            ? const Text('', style: TextStyle(fontSize: 20))
            : Text(
                player.number.toString(),
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                  fontSize: 16,
                ),
              ),
      ),
    );
  }
}

        pitchLeft + pitchWidth - penaltyAreaWidth,
        pitchTop + (pitchHeight - penaltyAreaHeight) / 2,
        penaltyAreaWidth,
        penaltyAreaHeight,
      ),
      linePaint,
    );

    // Right six-yard box
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft + pitchWidth - sixYardWidth,
        pitchTop + (pitchHeight - sixYardHeight) / 2,
        sixYardWidth,
        sixYardHeight,
      ),
      linePaint,
    );

    // Right goal
    canvas.drawRect(
      Rect.fromLTWH(
        pitchLeft + pitchWidth,
        pitchTop + (pitchHeight - pitchHeight * 0.2) / 2,
        5,
        pitchHeight * 0.2,
      ),
      linePaint,
    );
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}
